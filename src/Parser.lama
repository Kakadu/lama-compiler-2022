-- Parser

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr(l, p, r) {
  syntax (-l p -r)
}

fun binop(token) {
  [s(token), fun (l, op, r) { Binop(op, l, r) }]
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal { Const(stringInt(x)) }
  | x=lident { Var(x) }
  | inbr[s("("), exp, s(")")]),
    exp = memo $ eta expr(
    {
      [Left, map(binop, { "!!" })],
      [Left, map(binop, { "&&" })],
      [Nona, map(binop, { "<", ">", "<=", ">=", "==", "!=" })],
      [Left, map(binop, { "+", "-" })],
      [Left, map(binop, { "*", "/", "%" })]
    },
    primary);


var stmt = memo $ eta syntax (
  kSkip { Skip }
  | x=lident s[":="] e=exp { Assn(x, e) }
  | kRead x=inbr[s("("), lident, s(")")] { Read(x) }
  | kWrite e=inbr[s("("), exp, s(")")] { Write(e) }
  | kIf cond=exp kThen then_body=stmt_seq else_body=else_stmt { If(cond, then_body, else_body) }
  | kWhile cond=exp kDo body=stmt_seq kOd { While(cond, body) }
  | kDo body=stmt_seq kWhile cond=exp kOd { DoWhile(body, cond) }
  | kFor init=stmt_seq s[","] cond=exp s[","] act_after_loop=stmt_seq kDo body=stmt_seq kOd { Seq(init, While(cond, Seq(body, act_after_loop))) }
);

var else_stmt = memo $ eta syntax(
  kFi { Skip }
  | kElse body=stmt_seq kFi { body }
  | kElif cond=exp kThen then_body=stmt_seq else_body=else_stmt { If(cond, then_body, else_body) }
);

var stmt_seq = memo $ eta syntax(
  s1=stmt s[";"] s2=stmt_seq { Seq(s1, s2) }
  | s=stmt { s }
);


-- Public top-level parser
public parse = stmt_seq;

