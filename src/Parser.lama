-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun makeDescriptors (binops) {
  map (fun (binop) {
    [s (binop), fun (l, op, r) {Binop (op, l, r)}]
  }, binops)
}

fun brackets (e) {
  syntax (inbr[s ("("), e, s (")")])
}

-- Primary expression
var primary = memo $ eta syntax (
  x=decimal {Const (stringInt (x))} |
  x=lident {Var (x)}                |
  brackets[exp]
),
    exp = memo $ eta expr (
    {
      [Left, makeDescriptors $ {"!!"}],
      [Left, makeDescriptors $ {"&&"}],
      [Nona, makeDescriptors $ {"==", "!=", "<=", "<", ">=", ">"}],
      [Left, makeDescriptors $ {"+", "-"}],
      [Left, makeDescriptors $ {"*", "/", "%"}]
    },
    primary
  );

var primary_stmt = memo $ eta syntax(
  kSkip {Skip}                                            |
  kRead x=brackets[lident] {Read (x)}                     |
  kWrite e=brackets[exp] {Write (e)}                      |
  x=lident s[":="] e=exp {Assn (x, e)}                    |
  kIf e=exp kThen s1=stmts s2=if_closure {If (e, s1, s2)} |
  kWhile e=exp kDo s=stmts kOd {While (e, s)}             |
  kDo s=stmts kWhile e=exp kOd {DoWhile (s, e)}           |
  kFor s1=stmts s[","] e=exp s[","] s2=stmts kDo s3=stmts kOd {Seq (s1, While (e, Seq (s3, s2)))}
),
    if_closure = memo $ eta syntax(
    kFi {Skip}            |
    kElse s=stmts kFi {s} |
    kElif e=exp kThen s1=stmts s2=if_closure {If (e, s1, s2)}
  ),
    stmts = memo $ eta syntax(
    s1=primary_stmt s[";"] s2=stmts {Seq (s1, s2)} |
    primary_stmt
  )
;

-- Public top-level parser
public parse = stmts;
