-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr(l, p, r) {
  syntax (-l p -r)
}

fun makeDescriptors(binops) {
  map(fun (binop) {
    [s(binop), fun (l, op, r) { Binop(op, l, r) }]
  }, binops)
}

fun brackets(e) {
  syntax (inbr[s("("), e, s(")")])
}

-- Primary expression
var primary = memo $ eta syntax (
  x=decimal { Const(stringInt(x)) } |
  x=lident { Var(x) }               |
  brackets[exp]
),
    exp = memo $ eta expr(
    {
      [Left, makeDescriptors $ { "!!" }],
      [Left, makeDescriptors $ { "&&" }],
      [Nona, makeDescriptors $ { "==", "!=", "<=", "<", ">=", ">" }],
      [Left, makeDescriptors $ { "+", "-" }],
      [Left, makeDescriptors $ { "*", "/", "%" }]
    },
    primary
  );

var stmt = memo $ eta syntax(
  kSkip { Skip }                                   |
  kRead x=brackets[lident] { Read(x) } |
  kWrite e=brackets[exp] { Write(e) }  |
  x=lident s[":="] e=exp { Assn(x, e) }            |
  s1=stmt s[";"] s2=stmt end { Seq(s1, s2) }
);


-- Public top-level parser
public parse = stmt;
