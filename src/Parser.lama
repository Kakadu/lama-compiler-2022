-- Parser

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr(l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal { Const(stringInt(x)) } |
  x=lident { Var(x) }                                              |
  inbr[s("("), exp, s(")")]),
    binop = fun (l, op, r) { Binop(op, l, r) },

    exp = memo $ expr({
    [Left, { [s("^"), binop] }],
    [Left, { [s("!!"), binop] }],
    [Left, { [s("&&"), binop] }],
    [Nona, { [s("<"), binop], [s("<="), binop], [s("=="), binop],
      [s("!="), binop], [s(">="), binop], [s(">"), binop] }],
    [Left, { [s("+"), binop], [s("-"), binop] }],
    [Left, { [s("*"), binop], [s("/"), binop], [s("%"), binop] }]
  }, primary);

var stmt_part = memo $ eta syntax(v=lident s[":="] e=exp { Assn(v, e) }
  | kSkip { Skip }
  | kRead v=inbr[s("("), lident, s(")")] { Read(v) }
  | kWrite e=inbr[s("("), exp, s(")")] { Write(e) }
),
    stmt = memo $ eta syntax(f=stmt_part s[";"] r=stmt { Seq(f, r) }
    | s=stmt_part { s }
  );

-- Public top-level parser
public parse = stmt;

