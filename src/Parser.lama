-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;

-- Signals an error; takes an error message and location info
fun error(msg, loc) {
  failure("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- An attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")

-- Checks if a plain value "val" can be used in the context described by
-- the attribute "atr".
fun assertValue(atr, v, loc) {
  case atr of
    Ref    -> error("reference expected", loc)
    | Void -> Ignore(v)
    | _    -> v
  esac
}

fun assertVoid(atr, v, loc) {
  case atr of
    Void  -> v
    | Val -> error("value expected", loc)
    | _   -> error("reference expected", loc)
  esac
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr(l, p, r) {
  syntax (-l p -r)
}

fun binop(op) {
  [syntax (pos -s[op]), fun (l, loc, r) {
    fun (a) {
      assertValue(a, Binop(op, l(Val), r(Val)), loc)
    }
  }
  ]
}

fun ref(atr, v, loc) {
  case atr of
    Ref    -> Ref(v)
    | Void -> Ignore(Var(v))
    | _    -> Var(v)
  esac
}

fun par(p) {
  inbr(s("("), p, s(")"))
}

fun bops(aops) {
  map(fun ([assoc, ops]) { [assoc, map(binop, ops)] }, aops)
}

var assignOp = [Right,
  { [
    s(":="),
    fun (l, loc, r) {
      fun (a) {
        assertValue(a, Assn(l(Ref), r(Val)), loc)
      }
    }
  ] }
];
var elseBody = memo $ eta syntax (
  loc=pos kElse elseSt=exp kFi {
    fun (a) {
      elseSt(a)
    }
  }
  | loc=pos kElif ifSt=ifBody {
  fun (a) {
    ifSt(a)
  }
}
  | loc=pos kFi {
  fun (a) {
    assertVoid(a, Skip, loc)
  }
}
),
    ifBody = memo $ eta syntax (
    loc=pos cond=exp kThen thenB=exp elseB=elseBody {
      fun (a) {
        If(cond(Val), thenB(a), elseB(a))
      }
    }
  );

var primary = memo $ eta syntax (
  par[exp]
  | loc=pos kSkip { -- Skip
  fun (a) {
    assertVoid(a, Skip, loc)
  }
}
  | loc=pos kRead x=par[lident] { -- Read (x)
  fun (a) {
    assertVoid(a, Ignore(Read(x)), loc)
  }
}
  | loc=pos kWrite v=par[exp] { -- Write (v)
  fun (a) {
    assertVoid(a, Write(v(Val)), loc)
  }
}
  | loc=pos kIf body=ifBody {  -- If
  fun (a) {
    body(a)
  }
}
  | loc=pos kWhile cond=exp kDo x=exp kOd { -- While (cond, x)
  fun (a) {
    assertVoid(a, While(cond(Val), x(Void)), loc)
  }
}
  | loc=pos kFor x=exp s[","] cond=exp s[","] z=exp kDo y=exp kOd { -- x;While (cond, y;z)
  fun (a) {
    assertVoid(
      a,
      Seq(x(Void), While(cond(Val), Seq(y(Void), z(Void)))),
      loc
    )
  }
}
  | loc=pos kDo x=exp kWhile cond=exp kOd { -- DoWhile(x, cond)
  fun (a) {
    assertVoid(a, DoWhile(x(Void), cond(Val)), loc)
  }
}
  | loc=pos x=lident { -- Var (x) / Ref(x)
  fun (a) {
    ref(a, x, loc)
  }
}
  | loc=pos n=decimal { -- Const (n)
  fun (a) {
    assertValue(a, Const(stringInt(n)), loc)
  }
}
),
    basic = memo $ eta (expr(assignOp:bops({
    [Left, { "!!" }],
    [Left, { "&&" }],
    [Nona, { "==", "!=", "<", ">", "<=", ">=" }],
    [Left, { "+", "-" }],
    [Left, { "*", "/", "%" }]
  }),
    primary)),
    exp = memo $ eta syntax (basic | s1=basic s[";"] s2=exp { fun (a) { Seq(s1(Void), s2(a)) } });
-- Public top-level parser
public parse = syntax (s=exp { s(Void) });
