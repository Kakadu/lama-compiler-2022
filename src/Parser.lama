-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binop_descript(bops) {
  map (fun (bop) { [s (bop), fun (l, bop_, r) { Binop (bop_, l, r)}] }, bops)
}

-- Primary expression
var primary = memo $ eta syntax (
  x=decimal {Const (stringInt (x))} |
  x=lident  {Var (x)}               |
  inbr[s("("), exp, s(")")]
),
exp = memo $ expr ({
  [Left, binop_descript({"!!"})],
  [Left, binop_descript({"&&"})],
  [Nona, binop_descript({"==", "!=", "<=", "<", ">=", ">"})],
  [Left, binop_descript({"+", "-"})],
  [Left, binop_descript({"*", "/", "%"})]
}, primary);

var stmt = memo $ eta syntax (
  x=lident s[":="] e=exp { Assn (x, e) }                      |
  kSkip { Skip }                                              |
  kRead x=inbr[s("("), lident, s(")")] { Read (x) }           |
  kWrite e=inbr[s("("), exp, s(")")] { Write (e) }            |
  kIf cond=exp kThen s1=stmts s2=elseTail {If (cond, s1, s2)} |
  kWhile cond=exp kDo body=stmts kOd { While (cond, body) }   |
  kDo body=stmts kWhile cond=exp kOd { DoWhile (body, cond)}  |
  kFor s1=stmts s[","] cond=exp s[","] s2=stmts kDo s3=stmts kOd { Seq (s1, While (cond, Seq (s3, s2))) }
),
stmts = memo $ listBy (stmt, s (";")) @ fun (l_stmt) {
  foldl (fun (acc, s) {
    case acc of None -> s | _ -> Seq (acc, s) esac
  }, None, l_stmt)
},
elseTail = memo $ eta syntax (
  kFi { Skip }                                                    |
  -kElse stmts -kFi                                               |
  kElif cond=exp kThen s1=stmts s2=elseTail { If (cond, s1, s2) } 
);
   

-- Public top-level parser
public parse = stmts;