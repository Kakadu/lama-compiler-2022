-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun parserGenerator(l) {
  case l of
    {}        -> failure ("Can't generate parsers from empty list of tokens")
  | x : l -> foldl(fun (acc, op) {acc | s(op)} , s(x), l)
  esac
}

fun rule (l) {
  {[parserGenerator(l), fun (l, op, r) { Binop(op, l, r)}]}
}

-- Primary expression
var primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                          lident  @ fun (x) {Var (x)} |
                          inbr (s ("("), exp, s (")"))),
    exp = memo $ eta (primary | expr({[Left, rule({"!!"})],
                                      [Left, rule({"&&"})],
                                      [Nona, rule({"==", "!=", "<=", ">=", ">", "<"})],
                                      [Left, rule({"+", "-"})],
                                      [Left, rule({"*", "/", "%"})]},
                                     primary)),
    elifs = memo $ eta syntax (kElif e1=exp kThen s1=stmt s2=elifs { If(e1, s1, s2) }
                             | kElif e1=exp kThen s1=stmt kElse s2=stmt { If(e1, s1, s2) }
                             | kElif e1=exp kThen s1=stmt { If(e1, s1, Skip) }),
    stmt = memo $ eta syntax (x=lident s[":="] e=exp { Assn (x, e) }
                            | kSkip { Skip }
                            | kRead x=inbr[s("("), lident, s(")")] { Read(x) }
                            | kWrite e=inbr[s("("), exp, s(")")] { Write(e) }
                            | kIf e=exp kThen s1=stmts kElse s2=stmts kFi { If(e, s1, s2) }
                            | kIf e=exp kThen s1=stmts kFi { If(e, s1, Skip) }
                            | kWhile e=exp kDo s1=stmts kOd { While(e, s1) }
                            | kFor s1=stmts s[","] e=exp s[","] s2=stmts kDo s3=stmts kOd
                              { Seq(s1, While(e, Seq(s3, s2))) }
                            | kDo s1=stmts kWhile e=exp kOd { DoWhile(s1, e) }
                            | kIf e1=exp kThen s1=stmt s2=elifs kFi { If(e1, s1, s2) }),
    stmts = memo $ eta syntax (stmt | s1=stmt s[";"] ss=stmts { Seq(s1, ss) });
   

-- Public top-level parser
public parse = stmts;