-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr(l, p, r) {
  syntax (-l p -r)
}

fun binop (op) {
  [s (op), fun (l, op, r) {Binop (op, l, r)}]
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s $ "(", exp, s $ ")"]),
    exp = memo $ eta expr(
    {
      [Left, map(binop, { "!!" })],
      [Left, map(binop, { "&&" })],
      [Nona, map(binop, { "==", "!=", "<=", "<", ">=", ">" })],
      [Left, map(binop, { "+", "-" })],
      [Left, map(binop, { "*", "/", "%" })]
    },
    primary
  );

var stmt = memo $ eta syntax(
  -kSkip { Skip } |
  -kRead x=inbr[s $ "(", lident, s $ ")"] { Read(x) } |
  -kWrite e=inbr[s $ "(", exp, s $ ")"] { Write(e) } |
  x=lident -s[":="] e=exp { Assn(x, e) } |
  -kIf e=exp kThen s1=stmts s2=els { If(e, s1, s2) } |
  -kWhile e=exp kDo s=stmts kOd { While(e, s) } |
  -kDo s=stmts kWhile e=exp kOd { DoWhile(s, e) } |
  -kFor s1=stmts -s[","] e=exp -s[","] s2=stmts kDo s3=stmts kOd { Seq(s1, While(e, Seq(s3, s2))) }
),
  els = memo $ eta syntax(
    -kFi { Skip } |
    -kElse s=stmts -kFi { s } |
    -kElif e=exp -kThen s1=stmts s2=els { If(e, s1, s2) }
),
  stmts = memo $ eta syntax(
    s1=stmt -s[";"] s2=stmts { Seq(s1, s2) } |
    stmt
);

-- Public top-level parser
public parse = stmts;
