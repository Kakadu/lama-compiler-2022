-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun operatorDescriptor (op) {
  [s (op), fun (l, _, r) { Binop (op, l, r) }]
}

var operators = {
  [Left, {operatorDescriptor ("!!")}],
  [Left, {operatorDescriptor ("&&")}],
  [Nona, {
    operatorDescriptor ("<"),
    operatorDescriptor (">"),
    operatorDescriptor ("<="),
    operatorDescriptor (">="),
    operatorDescriptor ("=="),
    operatorDescriptor ("!=")
  }],
  [Left, {
    operatorDescriptor ("+"),
    operatorDescriptor ("-")
  }],
  [Left, {
    operatorDescriptor ("*"),
    operatorDescriptor ("/"),
    operatorDescriptor ("%")
  }]
};

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s ("("), exp, s (")")]),
      exp = memo $ eta expr (operators, primary) | primary;

var stmt = memo $ eta syntax (dst_var=lident s[":="] expr=exp {Assn (dst_var, expr)}        |
                              stmt1=stmt s[";"] stmt2=stmt end {Seq (stmt1, stmt2)}         |
                              kRead dst_var=inbr[s ("("), lident, s (")")] {Read (dst_var)} |
                              kWrite expr=inbr[s ("("), exp, s (")")] {Write (expr)});
   

-- Public top-level parser
public parse = stmt;
             
