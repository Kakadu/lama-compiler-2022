-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr(l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal { Const(stringInt(x)) } |
  x=lident { Var(x) }                                              |
  inbr[s("("), exp, s(")")]),
    binop = fun (l, op, r) { Binop(op, l, r) },

    exp = memo $ expr({
    [Left, { [s("^"), binop] }],
    [Left, { [s("!!"), binop] }],
    [Left, { [s("&&"), binop] }],
    [Nona, { [s("<"), binop], [s("<="), binop], [s("=="), binop],
      [s("!="), binop], [s(">="), binop], [s(">"), binop] }],
    [Left, { [s("+"), binop], [s("-"), binop] }],
    [Left, { [s("*"), binop], [s("/"), binop], [s("%"), binop] }]
  }, primary);

var stmt_part = memo $ eta syntax(v=lident s[":="] e=exp { Assn(v, e) }
  | kSkip { Skip }
  | kRead v=inbr[s("("), lident, s(")")] { Read(v) }
  | kWrite e=inbr[s("("), exp, s(")")] { Write(e) }
  | s=stmt_if { s }
  | s=stmt_while { s }),
    stmt = memo $ eta syntax(f=stmt_part s[";"] r=stmt { Seq(f, r) }
    | s=stmt_part { s }),
    stmt_if = memo $ eta syntax(kIf e=exp kThen s1=stmt s2=stmt_else { If(e, s1, s2) }),
    stmt_else = memo $ eta syntax(kFi { Skip }
    | kElse s=stmt kFi { s }
    | kElif e=exp kThen s1=stmt s2=stmt_else { If(e, s1, s2) }),
    stmt_while = memo $ eta syntax(kWhile e=exp kDo s=stmt kOd { While(e, s) }
    | kDo s=stmt kWhile e=exp kOd { DoWhile(s, e) }
    | kFor init=stmt s[","] e=exp s[","] each=stmt kDo s=stmt kOd { Seq(init, While(e, Seq(s, each))) });

-- Public top-level parser
public parse = stmt;
