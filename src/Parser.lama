-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr(l, p, r) {
  syntax (-l p -r)
}

-- Transforms list of binop strings into a list of descriptors
-- to use in expr superparser
fun binop_descrs(ts) {
  map(fun (t) { [s(t), fun (l, op, r) { Binop(op, l, r) }] }, ts)
}

-- Primary expression
var primary = memo $ eta syntax (
  x=decimal { Const(stringInt(x)) } |
  x=lident { Var(x) }               |
  inbr[s("("), exp, s(")")]
),
    exp = memo $ eta expr(
    {
      [Left, binop_descrs({ "!!" })],
      [Left, binop_descrs({ "&&" })],
      [Nona, binop_descrs({ "==", "!=", "<=", "<", ">=", ">" })],
      [Left, binop_descrs({ "+", "-" })],
      [Left, binop_descrs({ "*", "/", "%" })]
    },
    primary
  );

var if_tail = memo $ eta syntax (
  kElif e=exp kThen s1=stmts s2=if_tail { If(e, s1, s2) } |
  kElse s=stmts kFi { s }                                 |
  kFi { Skip }
),
    stmt = memo $ eta syntax (
    kSkip { Skip }                                        |
    x=lident s[":="] e=exp { Assn(x, e) }                 |
    kRead x=inbr[s("("), lident, s(")")] { Read(x) }      |
    kWrite e=inbr[s("("), exp, s(")")] { Write(e) }       |
    kIf e=exp kThen s1=stmts s2=if_tail { If(e, s1, s2) } |
    kWhile e=exp kDo s=stmts kOd { While(e, s) }          |
    kDo s=stmts kWhile e=exp kOd { DoWhile(s, e) }        |
    kFor s1=stmts s[","] e=exp s[","] s2=stmts kDo s3=stmts kOd { Seq(s1, While(e, Seq(s3, s2))) }
  ),
    stmts = memo $ eta syntax (
    s1=stmt s[";"] s2=stmts { Seq(s1, s2) } |
    stmt
  )
;

-- Public top-level parser
public parse = stmts;
