-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binop_descript(bops) {
  map (fun (bop) { [s (bop), fun (l, bop_, r) { Binop (bop_, l, r)}] }, bops)
}

-- Primary expression
var primary = memo $ eta syntax (
  x=decimal {Const (stringInt (x))} |
  x=lident  {Var (x)}               |
  inbr[s("("), exp, s(")")]
),
exp = memo $ expr ({
  [Left, binop_descript({"!!"})],
  [Left, binop_descript({"&&"})],
  [Nona, binop_descript({"==", "!=", "<=", "<", ">=", ">"})],
  [Left, binop_descript({"+", "-"})],
  [Left, binop_descript({"*", "/", "%"})]
}, primary);

var stmt = memo $ eta syntax (
  x=lident s[":="] e=exp { Assn (x, e) }            |
  kSkip { Skip }                                    |
  kRead x=inbr[s("("), lident, s(")")] { Read (x) } |
  kWrite e=inbr[s("("), exp, s(")")] { Write (e) }   
);

var stmts = memo $ listBy (stmt, s (";")) @ fun (l_stmt) {
  foldl (fun (acc, s) {
    case acc of None -> s | _ -> Seq (acc, s) esac
  }, None, l_stmt)
};
   

-- Public top-level parser
public parse = stmts;
             