-- Stack machine.

import List;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
    READ      -> sprintf ("READ")
  | WRITE     -> sprintf ("WRITE")
  | BINOP (s) -> sprintf ("BINOP %s", s)
  | LD    (x) -> sprintf ("LD %s", x)
  | ST    (x) -> sprintf ("ST %s", x)
  | CONST (n) -> sprintf ("CONST %d", n)
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval (c, insns) {
  var i = -1;
  var breakpoint = -1;

  fun popStack (stack) {
    case stack of
      {} -> failure ("Stack is empty\n")
    | v:{} -> {v, {}}
    | v:tl -> {v, tl}
    esac
  }

  fun pushStack (v, stack) {
    {v} +++ stack
  }

  fun performInstruction (c, ins) {
    var stack = c[0];
    var state = c[1];
    var world = c[2];
    i := i + 1;
    if i == breakpoint then failure (string ([stack, ins])) fi;
    case ins of
      READ -> (
        var valueWorldPair = readWorld (world);
        var value = valueWorldPair[0]; world := valueWorldPair[1];
        stack := pushStack (value, stack)
      )
    | WRITE -> (
        case popStack (stack) of
          value:{newStack} -> stack := newStack; world := writeWorld (value, world)
        esac
      )
    | BINOP (s) -> (
        case popStack (stack) of
          right:{firstPop} -> (
            case popStack (firstPop) of
              left:{secondPop} -> stack := pushStack (performBinop(s, left, right), secondPop)
            esac
          )
        esac
      )
    | LD (x) -> (
        stack := pushStack (state (x), stack)
      )
    | ST (x) -> (
      case popStack (stack) of
        value:{newStack} -> state := state <- [x, value]; stack := newStack
      esac
      )
    | CONST (n) -> (
        stack := pushStack (n, stack)
      )
    esac;
    [stack, state, world]
  }
  foldl (performInstruction, c, insns)
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine instructions
fun compileExpr (expr) {
  case expr of
    Const (n) -> {CONST (n)}
  | Var (s)   -> {LD (s)}
  | Binop (s, l_expr, r_expr) -> compileExpr (l_expr) +++ compileExpr (r_expr) +++ {BINOP (s)}
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  case stmt of
    Assn (s, expr) -> compileExpr(expr) +++ {ST (s)}
  | Read (s) -> {READ, ST (s)}
  | Write (expr) -> compileExpr(expr) +++ {WRITE}
  | Seq (l_stmt, r_stmt) -> compileSM (l_stmt) +++ compileSM (r_stmt)
  esac
}
